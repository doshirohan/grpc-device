<%
import common_helpers
import service_helpers

config = data['config']
enums = data['enums']
functions = data['functions']
lookup = data["lookup"]

service_class_prefix = config["service_class_prefix"]
namespace_prefix = "grpc::" + config["namespace_component"] + "::"
module_name = config["module_name"]
c_function_prefix = config["c_function_prefix"]
linux_library_name = config['library_info']['Linux']['64bit']['name']
windows_libary_name = config['library_info']['Windows']['64bit']['name']
if len(config["custom_types"]) > 0:
  custom_types = config["custom_types"]
%>\
<%namespace name="mako_helper" file="/service_helpers.mako"/>\

//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the ${config["driver_name"]} Metadata
//---------------------------------------------------------------------
#include "${module_name}_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>

namespace grpc {
namespace ${config["namespace_component"]} {

  ${service_class_prefix}Service::${service_class_prefix}Service(${service_class_prefix}LibraryInterface* library, grpc::nidevice::SessionRepository* session_repository)
      : library_(library), session_repository_(session_repository)
  {
  }

  ${service_class_prefix}Service::~${service_class_prefix}Service()
  {
  }

  % if 'custom_types' in locals():
  % for custom_type in custom_types:
  void ${service_class_prefix}Service::Copy(const ${custom_type["name"]}& input, ${namespace_prefix}${custom_type["grpc_name"]}* output) 
  {
% for field in custom_type["fields"]: 
    output->set_${field["grpc_name"]}(input.${field["name"]});
% endfor
  }

  void ${service_class_prefix}Service::Copy(const std::vector<${custom_type["name"]}>& input, google::protobuf::RepeatedPtrField<${namespace_prefix}${custom_type["grpc_name"]}>* output) 
  {
    for (auto item : input) {
      auto message = new ${namespace_prefix}${custom_type["grpc_name"]}();
      Copy(item, message);
      output->AddAllocated(message);
    }
  }

% endfor
% endif
% for function_name in service_helpers.filter_proto_rpc_functions_to_generate(functions):
<%
    function_data = functions[function_name]
    method_name = common_helpers.snake_to_pascal(function_name)
    parameters = function_data['parameters']
    service_helpers.sanitize_names(parameters)
    common_helpers.mark_non_grpc_params(parameters)
%>\
  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status ${service_class_prefix}Service::${method_name}(::grpc::ServerContext* context, const ${method_name}Request* request, ${method_name}Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
% if common_helpers.has_unsupported_parameter(function_data):
      return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
% elif common_helpers.is_init_method(function_data):
${mako_helper.gen_init_method_body(function_name=function_name, function_data=function_data, parameters=parameters)}
% elif common_helpers.has_ivi_dance_param(parameters):
${mako_helper.gen_ivi_dance_method_body(function_name=function_name, function_data=function_data, parameters=parameters)}
% else:
${mako_helper.gen_simple_method_body(function_name=function_name, function_data=function_data, parameters=parameters)}
% endif
    }
    catch (grpc::nidevice::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

% endfor
} // namespace ${config["namespace_component"]}
} // namespace grpc

